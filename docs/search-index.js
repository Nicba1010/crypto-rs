var searchIndex = {};
searchIndex["crypto_rs"] = {"doc":"This library provides common cryptographic functionality for working within the exponential ElGamal cryptosystem.","items":[[0,"arithmetic","crypto_rs","Adds support for modular arithmetic within a cyclic field of integers.",null,null],[0,"mod_int","crypto_rs::arithmetic","Modular arithmetic within a cyclic field",null,null],[3,"ModInt","crypto_rs::arithmetic::mod_int","An integer with modular operations.",null,null],[12,"value","","The value.",0,null],[12,"modulus","","The modulus.",0,null],[8,"From","","",null,null],[10,"from_value_modulus","","Create a ModInt with the given value and modulus.",1,{"inputs":[{"name":"bigint"},{"name":"bigint"}],"output":{"name":"modint"}}],[10,"from_value","","Create a ModInt with the given value and a zero modulus.",1,{"inputs":[{"name":"bigint"}],"output":{"name":"modint"}}],[10,"from_hex_string","","",1,{"inputs":[{"name":"string"},{"name":"bigint"}],"output":{"name":"modint"}}],[8,"RandModInt","","Random ModInt",null,null],[10,"gen_modint","","Generate random ModInts with the given upper_bound. Note, that the returned ModInt has a modulus set equal to the given upper_bound.",2,{"inputs":[{"name":"modint"}],"output":{"name":"modint"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone_from","","",0,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"from_value_modulus","","",0,{"inputs":[{"name":"bigint"},{"name":"bigint"}],"output":{"name":"modint"}}],[11,"from_value","","",0,{"inputs":[{"name":"bigint"}],"output":{"name":"modint"}}],[11,"from_hex_string","","",0,{"inputs":[{"name":"string"},{"name":"bigint"}],"output":{"name":"modint"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"zero","","Zero ModInt",0,{"inputs":[],"output":{"name":"self"}}],[11,"is_zero","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"one","","One ModInt",0,{"inputs":[],"output":{"name":"self"}}],[11,"is_one","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"neg","","",0,{"inputs":[{"name":"self"}],"output":{"name":"modint"}}],[11,"add","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"name":"modint"}}],[11,"sub","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"name":"modint"}}],[11,"mul","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"name":"modint"}}],[11,"div","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"name":"modint"}}],[11,"rem","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"name":"modint"}}],[11,"pow","","",0,{"inputs":[{"name":"self"},{"name":"modint"}],"output":{"name":"modint"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"gen_modint","","",0,{"inputs":[{"name":"modint"}],"output":{"name":"modint"}}],[0,"mod_inverse","crypto_rs::arithmetic","Perform the inverse operation in modular arithmetic",null,null],[5,"mod_inverse","crypto_rs::arithmetic::mod_inverse","Modular Inverse",null,{"inputs":[{"name":"bigint"},{"name":"bigint"}],"output":{"generics":["bigint"],"name":"option"}}],[0,"cai","crypto_rs","Adds a universal cast-as-intended proof for a particular ElGamal ciphertext.",null,null],[0,"uciv","crypto_rs::cai","",null,null],[3,"PreImageSet","crypto_rs::cai::uciv","Secret UCIV Information `(x1, x2, ..., xn)`. This information is specific to a particular voter. Each `xn` is further tight to the n-th voting option.",null,null],[12,"pre_images","","",3,null],[3,"ImageSet","","Public UCIV Information `(y1, y2, ..., yn)`. This information is specific to a particular voter. Each `yn` is further tight to the n-th voting option.",null,null],[12,"images","","",4,null],[3,"CaiProof","","Cast-as-Intended proof",null,null],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"preimageset"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"imageset"}}],[11,"new","","Creates an ImageSet `(y1, y2, ..., yn)` by applying the following arithmetic operation to each element of the given PreImageSet `(x1, x2, ..., xn)`:",4,{"inputs":[{"name":"modint"},{"name":"usize"},{"name":"preimageset"}],"output":{"name":"self"}}],[11,"new","","Create a new Cast-as-Intended Proof.",5,{"inputs":[{"name":"publickey"},{"name":"ciphertext"},{"name":"preimageset"},{"name":"imageset"},{"name":"usize"},{"generics":["modint"],"name":"vec"}],"output":{"name":"self"}}],[11,"verify","","Verify this proof for validity.",5,{"inputs":[{"name":"self"},{"name":"publickey"},{"name":"ciphertext"},{"name":"imageset"},{"generics":["modint"],"name":"vec"}],"output":{"name":"bool"}}],[0,"el_gamal","crypto_rs","Adds support for encrypting and decrypting messages in the exponential ElGamal cryptosystem, applying homomorphic addition on the ciphertexts. In addition, membership proofs can be generated for a ciphertext, ensuring that the encrypted plain-text message is within a particular bound.",null,null],[0,"additive","crypto_rs::el_gamal","",null,null],[8,"Operate","crypto_rs::el_gamal::additive","Homomorphic Operation",null,null],[10,"operate","","",6,{"inputs":[{"name":"self"},{"name":"ciphertext"}],"output":{"name":"ciphertext"}}],[0,"ciphertext","crypto_rs::el_gamal","",null,null],[3,"CipherText","crypto_rs::el_gamal::ciphertext","ElGamal CipherText.",null,null],[12,"big_g","","",7,null],[12,"big_h","","",7,null],[12,"random","","",7,null],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"ciphertext"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"encryption","crypto_rs::el_gamal","",null,null],[3,"PublicKey","crypto_rs::el_gamal::encryption","",null,null],[12,"p","","",8,null],[12,"q","","",8,null],[12,"h","","",8,null],[12,"g","","",8,null],[3,"PrivateKey","","",null,null],[12,"p","","",9,null],[12,"q","","",9,null],[12,"g","","",9,null],[12,"x","","",9,null],[5,"encrypt","","",null,{"inputs":[{"name":"publickey"},{"name":"modint"}],"output":{"name":"ciphertext"}}],[5,"decrypt","","",null,{"inputs":[{"name":"privatekey"},{"name":"ciphertext"}],"output":{"name":"modint"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"publickey"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"privatekey"}}],[0,"membership_proof","crypto_rs::el_gamal","",null,null],[3,"MembershipProof","crypto_rs::el_gamal::membership_proof","",null,null],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"membershipproof"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",10,{"inputs":[{"name":"publickey"},{"name":"modint"},{"name":"ciphertext"},{"generics":["modint"],"name":"vec"}],"output":{"name":"membershipproof"}}],[11,"verify","","",10,{"inputs":[{"name":"self"},{"name":"publickey"},{"name":"ciphertext"},{"generics":["modint"],"name":"vec"}],"output":{"name":"bool"}}],[0,"serializer","crypto_rs::el_gamal","",null,null],[3,"Serializer","crypto_rs::el_gamal::serializer","",null,null],[11,"string_to_sha512","","",11,{"inputs":[{"name":"string"}],"output":{"name":"string"}}],[11,"operate","crypto_rs::el_gamal::ciphertext","",7,{"inputs":[{"name":"self"},{"name":"ciphertext"}],"output":{"name":"ciphertext"}}]],"paths":[[3,"ModInt"],[8,"From"],[8,"RandModInt"],[3,"PreImageSet"],[3,"ImageSet"],[3,"CaiProof"],[8,"Operate"],[3,"CipherText"],[3,"PublicKey"],[3,"PrivateKey"],[3,"MembershipProof"],[3,"Serializer"]]};
initSearch(searchIndex);
